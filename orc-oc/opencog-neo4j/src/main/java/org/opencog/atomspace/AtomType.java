package org.opencog.atomspace;

import com.google.common.base.CaseFormat;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;

/**
 * <p>i.e. {@code ConceptNode}, {@code GeneNode}, {@code PredicateNode}, {@code PhraseNode}, {@code WordNode}, etc.</p>
 *
 * <p>Hendy's proposal: The AtomType is a Neo4j label of a {@link Node} or {@link Link}.
 * Most {@link Link}s .</p>
 *
 * <p>For ordering, see: opencog/atomspace/atom_types.definitions (TODO: should use id-map)</p>
 *
 * @todo Determine what's the best way to implement Atom types, in a way that is performant
 * (both Java-wise and DB-wise) and is relatively portable in the Neo4j database.
 * (i.e. autogenerated numeric identifiers may be problematic)
 */
public enum AtomType {
    // opencog/atomspace/atom_types.definitions
    ATOM(null, null), // 0
    NODE(GraphMapping.VERTEX, null), // 1
    LINK(GraphMapping.HYPEREDGE, null), // 2
    CONCEPT_NODE(GraphMapping.VERTEX, "opencog_ConceptNode"), // 3
    NUMBER_NODE(GraphMapping.VERTEX, "opencog_NumberNode"),
    ORDERED_LINK(GraphMapping.HYPEREDGE, "opencog_OrderedLink"),
    UNORDERED_LINK(GraphMapping.HYPEREDGE, "opencog_UnorderedLink"),
    SET_LINK(GraphMapping.HYPEREDGE, "opencog_SetLink"),
    LIST_LINK(GraphMapping.HYPEREDGE, "opencog_ListLink"),
    /**
     * rdf_type relationship
     */
    MEMBER_LINK(GraphMapping.BINARY_HYPEREDGE, "rdf_type"),
    SUBSET_LINK(GraphMapping.HYPEREDGE, "opencog_SubsetLink"),
    INTENSIONAL_INHERITANCE_LINK(GraphMapping.BINARY_HYPEREDGE, "opencog_IntensionalInheritanceLink"),
    EXTENSIONAL_SIMILARITY_LINK(GraphMapping.HYPEREDGE, "opencog_ExtensionalSimilarityLink"),
    INTENSIONAL_SIMILARITY_LINK(GraphMapping.HYPEREDGE, "opencog_IntensionalSimilarityLink"),
    AND_LINK(GraphMapping.HYPEREDGE, "opencog_AndLink"),
    OR_LINK(GraphMapping.HYPEREDGE, "opencog_OrLink"),
    NOT_LINK(GraphMapping.HYPEREDGE, "opencog_NotLink"),
    SEQUENTIAL_AND_LINK(GraphMapping.HYPEREDGE, "opencog_SequentialAndLink"),
    ABSENT_LINK(GraphMapping.HYPEREDGE, "opencog_AbsentLink"),
    CHOICE_LINK(GraphMapping.HYPEREDGE, "opencog_ChoiceLink"),
    PRESENT_LINK(GraphMapping.HYPEREDGE, "opencog_PresentLink"),
    CONTEXT_LINK(GraphMapping.HYPEREDGE, "opencog_ContextLink"),
    TYPE_NODE(GraphMapping.VERTEX, "opencog_TypeNode"),
    TYPE_CHOICE(GraphMapping.VERTEX, "opencog_TypeChoice"),
    VARIABLE_NODE(GraphMapping.VERTEX, "opencog_VariableNode"),
    TYPED_VARIABLE_LINK(GraphMapping.HYPEREDGE, "opencog_TypedVariableLink"),
    VARIABLE_LIST(GraphMapping.VERTEX, "opencog_VariableList"),
    LAMBDA_LINK(GraphMapping.HYPEREDGE, "opencog_LambdaLink"),
    DEFINE_LINK(GraphMapping.HYPEREDGE, "opencog_DefineLink"),
    PUT_LINK(GraphMapping.HYPEREDGE, "opencog_PutLink"),
    PATTERN_LINK(GraphMapping.HYPEREDGE, "opencog_PatternLink"),
    GET_LINK(GraphMapping.HYPEREDGE, "opencog_GetLink"),
    SATISFACTION_LINK(GraphMapping.HYPEREDGE, "opencog_SatisfactionLink"),
    BIND_LINK(GraphMapping.HYPEREDGE, "opencog_BindLink"),
    QUOTE_LINK(GraphMapping.HYPEREDGE, "opencog_QuoteLink"),
    UNQUOTE_LINK(GraphMapping.HYPEREDGE, "opencog_UnquoteLink"),
    FORALL_LINK(GraphMapping.HYPEREDGE, "opencog_ForallLink"),
    EXISTS_LINK(GraphMapping.HYPEREDGE, "opencog_ExistsLink"),
    AVERAGE_LINK(GraphMapping.HYPEREDGE, "opencog_AverageLink"),
    SATISFYING_SET_LINK(GraphMapping.HYPEREDGE, "opencog_SatisfyingSetLink"),
    SCHOLEM_LINK(GraphMapping.HYPEREDGE, "opencog_ScholemLink"),
    IMPLICATION_LINK(GraphMapping.HYPEREDGE, "opencog_ImplicationLink"),
    EQUIVALENCE_LINK(GraphMapping.HYPEREDGE, "opencog_EquivalenceLink"),
    ASSOCIATIVE_LINK(GraphMapping.HYPEREDGE, "opencog_AssociativeLink"),
    /**
     * rdfs_subClassOf relationship
     */
    INHERITANCE_LINK(GraphMapping.BINARY_HYPEREDGE, "rdfs_subClassOf"),
    SIMILARITY_LINK(GraphMapping.HYPEREDGE, "opencog_SimilarityLink"),
    ATTRACTION_LINK(GraphMapping.HYPEREDGE, "opencog_AttractionLink"),
    FREE_LINK(GraphMapping.HYPEREDGE, "opencog_FreeLink"),
    EVALUATION_LINK(GraphMapping.HYPEREDGE, "opencog_EvaluationLink"),
    EXECUTION_LINK(GraphMapping.HYPEREDGE, "opencog_ExecutionLink"),
    PROCEDURE_NODE(GraphMapping.VERTEX, "opencog_ProcedureNode"),
    GROUNDED_PROCEDURE_NODE(GraphMapping.VERTEX, "opencog_GroundedProcedureNode"),
    SCHEMA_NODE(GraphMapping.VERTEX, "opencog_SchemaNode"),
    DEFINED_SCHEMA_NODE(GraphMapping.VERTEX, "opencog_DefinedSchemaNode"),
    GROUNDED_SCHEMA_NODE(GraphMapping.VERTEX, "opencog_GroundedSchemaNode"),
    PREDICATE_NODE(GraphMapping.VERTEX, "opencog_PredicateNode"),
    DEFINED_PREDICATE_NODE(GraphMapping.VERTEX, "opencog_DefinedPredicateNode"),
    GROUNDED_PREDICATE_NODE(GraphMapping.VERTEX, "opencog_GroundedPredicateNode"),
    SCHEMA_EXECUTION_LINK(GraphMapping.HYPEREDGE, "opencog_SchemaExecutionLink"),
    SCHEMA_EVALUATION_LINK(GraphMapping.HYPEREDGE, "opencog_SchemaEvaluationLink"),
    ANCHOR_NODE(GraphMapping.VERTEX, "opencog_AnchorNode"),
    QUANTITY_LINK(GraphMapping.HYPEREDGE, "opencog_QuantityLink"),
    VIRTUAL_LINK(GraphMapping.HYPEREDGE, "opencog_VirtualLink"),
    GREATER_THAN_LINK(GraphMapping.HYPEREDGE, "opencog_GreaterThanLink"),
    EQUAL_LINK(GraphMapping.HYPEREDGE, "opencog_EqualLink"),
    FUNCTION_LINK(GraphMapping.HYPEREDGE, "opencog_FunctionLink"),
    EXECUTION_OUTPUT_LINK(GraphMapping.HYPEREDGE, "opencog_ExecutionOutputLink"),
    FOLD_LINK(GraphMapping.HYPEREDGE, "opencog_FoldLink"),
    ARITHMETIC_LINK(GraphMapping.HYPEREDGE, "opencog_ArithmeticLink"),
    PLUS_LINK(GraphMapping.HYPEREDGE, "opencog_PlusLink"),
    TIMES_LINK(GraphMapping.HYPEREDGE, "opencog_TimesLink"),
    DELETE_LINK(GraphMapping.HYPEREDGE, "opencog_AssignLink"),
    INSERT_LINK(GraphMapping.HYPEREDGE, "opencog_InsertLink"),
    REMOVE_LINK(GraphMapping.HYPEREDGE, "opencog_RemoveLink"),
    // extras
    WORD_NODE(GraphMapping.VERTEX, "opencog_WordNode"),
    MULTIPARENT_LINK(GraphMapping.HYPEREDGE, "opencog_MultiparentLink"),
    GENE_NODE(GraphMapping.VERTEX, "opencog_GeneNode"),
    PHRASE_NODE(GraphMapping.VERTEX, "opencog_PhraseNode");

    static final ImmutableBiMap<Integer, AtomType> atomTypeInfos;

    static {
        final HashMap<Integer, AtomType> atomTypeInfob = new HashMap<>();
        Arrays.stream(values())
                .forEach(it -> atomTypeInfob.put(atomTypeInfob.size(), it)); // must NOT be concurrent!
        atomTypeInfos = ImmutableBiMap.copyOf(atomTypeInfob);
    }

    private GraphMapping graphMapping;
    private String graphLabel;

    AtomType(GraphMapping graphMapping, String graphLabel) {
        this.graphMapping = graphMapping;
        this.graphLabel = graphLabel;
    }

    public GraphMapping getGraphMapping() {
        return graphMapping;
    }

    public String getGraphLabel() {
        return graphLabel;
    }

    public String toUpperCamel() { return CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL, name()); }

    public List<EdgeMapping> getEdgeMappings(int outgoingCount) {
        final ImmutableList.Builder<EdgeMapping> mappingb = ImmutableList.builder();
        if (this == EVALUATION_LINK) {
            mappingb.add(new EdgeMapping("opencog_predicate"));
            for (int i = 0; i < outgoingCount - 1; i++) {
                mappingb.add(new EdgeMapping("opencog_parameter", ImmutableMap.of("position", i)));
            }
        } else {
            for (int i = 0; i < outgoingCount; i++) {
                mappingb.add(new EdgeMapping("opencog_parameter", ImmutableMap.of("position", i)));
            }
        }
        return mappingb.build();
    }

    public static AtomType forGraphLabel(String label) {
        for (final AtomType atomType : AtomType.values()) {
            if (atomType.getGraphLabel() != null && atomType.getGraphLabel().equals(label)) {
                return atomType;
            }
        }
        throw new IllegalArgumentException("Unknown AtomType for label '" + label + "'");
    }

    public static AtomType forUpperCamel(String camelType) {
        return valueOf(CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, camelType));
    }

    public int getId() {
        return Preconditions.checkNotNull(atomTypeInfos.inverse().get(this),
            "Cannot find atom type '%s' in %s infos: %s", this, atomTypeInfos.size(),
                atomTypeInfos.inverse());
    }

    public static AtomType forId(int id) {
        return atomTypeInfos.get(id);
    }

}
